#version 430 core
layout(local_size_x = 1,local_size_y = 1,local_size_z = 1) in;

layout(std430, binding =2) buffer CleanVertices{
	
	float cleanVertices[];

};


layout(std430, binding =3) buffer FaceNormals{
	
	float faceNormals[];

};
uniform int resolution;
float densityFunc(vec3 ws){ // this function should be same with actual density funciton in marchingCubes.comp
	return ws.x *ws.x+ws.y*ws.y + ws.z*ws.z -resolution*(resolution-1);
}
vec3 computeGradient(vec3 ws){
	vec3 gradient;
	float epsilon =1.0/float(resolution);
	gradient.x=  (densityFunc(vec3(ws.x + epsilon, ws.y, ws.z)) - densityFunc(vec3(ws.x - epsilon, ws.y, ws.z))) / (2 * epsilon);
	
	gradient.y=  (densityFunc(vec3(ws.x , ws.y+ epsilon, ws.z)) - densityFunc(vec3(ws.x , ws.y- epsilon, ws.z))) / (2 * epsilon);
	
	gradient.z=  (densityFunc(vec3(ws.x , ws.y, ws.z+ epsilon)) - densityFunc(vec3(ws.x , ws.y, ws.z- epsilon))) / (2 * epsilon);
	return gradient;
}

void main(){
	uint cIndex=  gl_WorkGroupID.x*9;

	
	for(int i = 0; i<9; i+=3){
		vec3 vert = vec3(cleanVertices[cIndex+i],cleanVertices[cIndex+i+1],cleanVertices[cIndex+i+2]);
		vec3 normal = normalize(computeGradient(vert));
		faceNormals[cIndex+i] = normal.x;
		faceNormals[cIndex+i+1] = normal.y;
		faceNormals[cIndex+i+2] = normal.z;

	}

}
